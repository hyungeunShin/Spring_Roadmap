package hello;

public class Micrometer {
    /*
    마이크로미터
        서비스를 운영할 때는 애플리케이션의 CPU, 메모리, 커넥션 사용, 고객 요청수 같은 수 많은 지표들을 확인하는 것이 필요하다.
        그래야 어디에 어떤 문제가 발생했는지 사전에 대응도 할 수 있고, 실제 문제가 발생해도 원인을 빠르게 파악해서 대처할 수 있다.
        예를 들어서 메모리 사용량이 가득 찼다면 메모리 문제와 관련있는 곳을 빠르게 찾아서 대응할 수 있을 것이다.

        세상에는 수 많은 모니터링 툴이 있고, 시스템의 다양한 정보를 이 모니터링 툴에 전달해서 사용하게 된다.
        이런 모니터링 툴이 작동하려면 시스템의 다양한 지표들을 각각의 모니터링 툴에 맞도록 만들어서 보내주어야 한다.(실제로는 라이브러리등을 통해서 자동화 되는 경우가 많다.)
        예를 들어서 CPU, JVM, 커넥션 정보 등을 JMX 툴에 전달한다고 가정해보자.
        그러면 각각의 정보를 JMX 모니터링 툴이 정한 포멧에 맞추어 측정하고 전달해야 한다.

        그런데 중간에 사용하는 모니터링 툴을 변경하면 어떻게 될까?
        기존에 측정했던 코드를 모두 변경한 툴에 맞도록 다시 변경해야 한다.
        개발자 입장에서는 단순히 툴 하나를 변경했을 뿐인데, 측정하는 코드까지 모두 변경해야 하는 문제가 발생한다.
        이런 문제를 해결하는 것이 바로 마이크로미터(Micrometer)라는 라이브러리이다.

        - 마이크로미터는 애플리케이션 메트릭 파사드라고 불리는데, 애플리케이션의 메트릭(측정 지표)을 마이크로미터가 정한 표준 방법으로 모아서 제공해준다.
        - 쉽게 이야기해서 마이크로미터가 추상화를 통해서 구현체를 쉽게 갈아끼울 수 있도록 해두었다.
        - 보통은 스프링이 이런 추상화를 직접 만들어서 제공하지만, 마이크로미터라는 이미 잘 만들어진 추상화가 있기 때문에 스프링은 이것을 활용한다.
          스프링 부트 액츄에이터는 마이크로미터를 기본으로 내장해서 사용한다.
            - 로그를 추상화 하는 SLF4J 를 떠올려보면 쉽게 이해가 될 것이다.
        - 개발자는 마이크로미터가 정한 표준 방법으로 메트릭(측정 지표)를 전달하면 된다.
          그리고 사용하는 모니터링 툴에 맞는 구현체를 선택하면 된다. 이후에 모니터링 툴이 변경되어도 해당 구현체만 변경하면 된다.
          애플리케이션 코드는 모니터링 툴이 변경되어도 그대로 유지할 수 있다.

        각 모니터링 툴에 대한 자세한 내용은 마이크로미터 공식 메뉴얼을 참고
            https://micrometer.io/docs/

    메트릭 확인
        CPU, JVM, 커넥션 사용 등등 수 많은 지표들을 어떻게 수집해야 할까?
        개발자가 각각의 지표를 직접 수집해서 그것을 마이크로미터가 제공하는 표준 방법에 따라 등록하면 된다.
        다행히도 마이크로미터는 다양한 지표 수집 기능을 이미 만들어서 제공한다.
        그리고 스프링 부트 액츄에이터는 마이크로미터가 제공하는 지표 수집을 @AutoConfiguration 을 통해 자동으로 등록해준다.
        쉽게 이야기해서 스프링 부트 액츄에이터를 사용하면 수 많은 메트릭(지표)를 편리하게 사용할 수 있다.

        메트릭 엔드포인트
            http://localhost/actuator/metrics
        메트릭 상세
            http://localhost/actuator/metrics/{name}

        Tag 필터
            메트릭 상세에 availableTags 가 존재하는 항목이 있다.
            availableTags 를 보면 다음과 같은 항목을 확인할 수 있다.
            예시)
                "availableTags": [
                {
                    "tag": "area",
                    "values": [
                        "heap",
                        "nonheap"
                    ]
                }
            해당 Tag 를 기반으로 정보를 필터링해서 확인할 수 있다.
            tag=KEY:VALUE 과 같은 형식을 사용해야 한다.
                http://localhost/actuator/metrics/jvm.memory.used?tag=area:heap
                http://localhost/actuator/metrics/jvm.memory.used?tag=area:nonheap
                http://localhost/actuator/metrics/http.server.requests?tag=uri:/log

    다양한 메트릭
        - JVM 메트릭
            JVM 관련 메트릭을 제공한다. jvm. 으로 시작한다.

            - 메모리 및 버퍼 풀 세부 정보
            - 가비지 수집 관련 통계
            - 스레드 활용
            - 로드 및 언로드된 클래스 수
            - JVM 버전 정보
            - JIT 컴파일 시간

        - 시스템 메트릭
            시스템 메트릭을 제공한다. system. , process. , disk. 으로 시작한다.

            - CPU 지표
            - 파일 디스크립터 메트릭
            - 가동 시간 메트릭
            - 사용 가능한 디스크 공간

        - 애플리케이션 시작 메트릭
            애플리케이션 시작 시간 메트릭을 제공한다.

            - application.started.time : 애플리케이션을 시작하는데 걸리는 시간(ApplicationStartedEvent 로 측정)
                ApplicationStartedEvent : 스프링 컨테이너가 완전히 실행된 상태이다. 이후에 커맨드 라인 러너가 호출된다.
            - application.ready.time : 애플리케이션이 요청을 처리할 준비가 되는데 걸리는 시간(ApplicationReadyEvent 로 측정)
                ApplicationReadyEvent : 커맨드 라인 러너가 실행된 이후에 호출된다.

        - 스프링 MVC 메트릭
            스프링 MVC 컨트롤러가 처리하는 모든 요청을 다룬다.
            메트릭 이름: http.server.requests

            TAG 를 사용해서 다음 정보를 분류해서 확인할 수 있다.
                - uri : 요청 URI
                - method : GET, POST 같은 HTTP 메서드
                - status : 200, 400, 500 같은 HTTP Status 코드
                - exception : 예외
                - outcome : 상태코드를 그룹으로 모아서 확인 1xx:INFORMATIONAL, 2xx:SUCCESS, 3xx:REDIRECTION, 4xx:CLIENT_ERROR, 5xx:SERVER_ERROR

        - 톰캣 메트릭
            톰캣 메트릭은 tomcat. 으로 시작한다.
            톰캣 메트릭을 모두 사용하려면 다음 옵션을 켜야한다. (옵션을 켜지 않으면 tomcat.session. 관련 정보만 노출된다.)
                #톰캣의 최대 쓰레드, 사용 쓰레드 수를 포함한 다양한 메트릭을 확인할 수 있다.
                application.properties -> server.tomcat.mbeanregistry.enabled=true

        - 데이터 소스 메트릭
            DataSource, 커넥션 풀에 관한 메트릭을 확인할 수 있다.
            jdbc.connections. 으로 시작한다.
            최대 커넥션, 최소 커넥션, 활성 커넥션, 대기 커넥션 수 등을 확인할 수 있다.
            히카리 커넥션 풀을 사용하면 hikaricp. 를 통해 히카리 커넥션 풀의 자세한 메트릭을 확인할 수 있다.

        - 로그 메트릭
            logback.events : logback 로그에 대한 메트릭을 확인할 수 있다.
            trace, debug, info, warn, error 각각의 로그 레벨에 따른 로그 수를 확인할 수 있다.
            예를 들어서 error 로그 수가 급격히 높아진다면 위험한 신호로 받아드릴 수 있다.

        - 기타 수 많은 메트릭이 있다.
            - HTTP 클라이언트 메트릭(RestTemplate , WebClient)
            - 캐시 메트릭
            - 작업 실행과 스케줄 메트릭
            - 스프링 데이터 리포지토리 메트릭
            - 몽고 DB 메트릭
            - 레디스 메트릭

        - 사용자가 메트릭을 직접 정의하는 것도 가능하다.

        참고
            https://docs.spring.io/spring-boot/reference/actuator/metrics.html#actuator.metrics.supported

    정리
        액츄에이터를 통해서 수 많은 메트릭이 자동으로 만들어지는 것을 확인했다.
        그런데 이러한 메트릭들을 어딘가에 지속해서 보관해야 과거의 데이터들도 확인할 수 있을 것이다.
        따라서 메트릭을 지속적으로 수집하고 보관할 데이터베이스가 필요하다.
        그리고 이러한 메트릭들을 그래프를 통해서 한눈에 쉽게 확인할 수 있는 대시보드도 필요하다.

        1. 스프링 부트 액츄에이터와 마이크로미터를 사용하면 수 많은 메트릭을 자동으로 생성한다.
           마이크로미터 프로메테우스 구현체는 프로메테우스가 읽을 수 있는 포멧으로 메트릭을 생성한다.
        2. 프로메테우스는 이렇게 만들어진 메트릭을 지속해서 수집한다.
        3. 프로메테우스는 수집한 메트릭을 내부 DB에 저장한다.
        4. 사용자는 그라파나 대시보드 툴을 통해 그래프로 편리하게 메트릭을 조회한다. 이때 필요한 데이터는 프로메테우스를 통해서 조회한다.
    */
}
